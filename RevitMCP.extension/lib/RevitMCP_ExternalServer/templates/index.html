<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RevitMCP Chat</title>
    <script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f6f8;
            display: flex;
            height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }

        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
            /* position: relative; */ /* No longer needed for absolute sidebar */
        }

        #sidebar {
            width: 280px; 
            background-color: #202123; 
            color: #ececec;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Or 100% if app-container is strictly 100vh */
            overflow-y: auto;
            /* position: absolute; */ /* No longer absolute */
            /* top: 0; */
            /* left: 0; */
            /* z-index: 1100; */
            /* transform: translateX(-100%); */ /* Not using transform for hiding anymore */
            transition: width 0.3s ease, padding-left 0.3s ease, padding-right 0.3s ease; 
            flex-shrink: 0; /* Prevent sidebar from shrinking unintendedly */
        }

        /* State when sidebar is closed */
        #sidebar.sidebar-closed {
            width: 0;
            padding-left: 0;
            padding-right: 0;
            overflow: hidden; /* Hide content when collapsed */
        }

        #sidebar.sidebar-closed h2,
        #sidebar.sidebar-closed ul,
        #sidebar.sidebar-closed .sidebar-actions {
            display: none; /* Ensure content is hidden */
        }

        #sidebar h2 {
            margin-top: 0;
            font-size: 1.2em;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            color: #007bff;
        }

        #sidebar ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
        }

        #sidebar li {
            padding: 10px 5px;
            margin-bottom: 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #sidebar li:hover {
            background-color: #343541;
        }
        
        #sidebar li.active-chat {
            background-color: #4a4a64;
            font-weight: bold;
        }
        
        .sidebar-actions {
            display: flex;
            gap: 10px; /* Space between new chat and settings */
            margin-top: auto; /* Pushes to the bottom */
        }

        #new-chat-button {
            flex-grow: 1; /* Allow it to take available space */
            background-color: #343541;
            color: #ececec;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
        }
        #new-chat-button:hover {
            background-color: #4a4a64;
        }

        #settings-button {
            background-color: #343541;
            color: #ececec;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2em; /* Make icon slightly larger */
            line-height: 1; /* Adjust for vertical alignment if needed */
            width: 40px; /* Fixed width for icon button */
            text-align: center;
        }
        #settings-button:hover {
            background-color: #4a4a64;
        }

        #chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: #ffffff;
        }

        #top-bar {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: #f0f0f0; /* Same as old controls, or a new color */
            border-bottom: 1px solid #e0e0e0;
            gap: 10px; /* Space between buttons and controls */
        }

        #top-bar button {
            background-color: transparent;
            border: none;
            font-size: 1.5em; /* Make icons larger */
            padding: 5px;
            cursor: pointer;
            color: #333;
        }
        #top-bar button:hover {
            color: #007bff;
        }

        /* Adjustments for existing #controls if needed, now that it's in a flex container */
        #controls {
            /* padding: 15px; */ /* Padding is now on top-bar */
            /* background-color: #f0f0f0; */ /* Background is now on top-bar */
            /* border-bottom: 1px solid #e0e0e0; */ /* Border is now on top-bar */
            display: flex; /* Keep its own items flexible if necessary */
            gap: 5px; /* Reduced gap if items were too spaced */
            align-items: center;
            /* flex-wrap: wrap; */ /* May not be needed if top-bar handles wrapping or has enough space */
            margin-left: auto; /* Push model selector to the right */
        }
        #controls label, #controls select, #controls input, #controls button {
            /* margin-right: 5px; */ /* Gap handles spacing now */
            font-size: 0.9em;
        }
        #controls input[type="text"], #controls select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        #message-log {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            background-color: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            /* Styles for .message, .user-message, .bot-message will be removed from here */
        }

        /* Markdown specific styles for bot messages */
        .bot-message pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
        }
        .bot-message code { /* Inline code */
            background-color: #f0f0f0;
            color: #c7254e;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: "Courier New", Courier, monospace;
        }
        .bot-message h1, .bot-message h2, .bot-message h3 {
            margin-top: 1em;
            margin-bottom: 0.5em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.3em;
        }
        .bot-message ul, .bot-message ol {
            padding-left: 20px;
        }
        .bot-message blockquote {
            border-left: 4px solid #ccc;
            padding-left: 10px;
            color: #666;
            margin-left: 0;
        }
        .bot-message table {
            border-collapse: collapse;
            margin-bottom: 1em;
            width: auto;
        }
        .bot-message th, .bot-message td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .bot-message th {
            background-color: #f2f2f2;
        }

        #input-area {
            display: flex;
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            background-color: #f8f9fa;
        }

        #message-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 20px;
            margin-right: 10px;
            font-size: 1em;
        }

        #send-button {
            padding: 10px 20px;
            background-color: #1362bb;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1em;
        }
        #send-button:hover {
            background-color: #164881;
        }
        
        #status {
            padding: 5px 15px;
            background-color: #f0f0f0;
            font-size: 0.8em;
            text-align: center;
            color: #666;
        }

        /* Settings Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 25px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
        }

        .modal-content h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .modal-content label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .modal-content input[type="password"], .modal-content input[type="text"] {
            width: calc(100% - 22px); /* Full width minus padding and border */
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
        }

        #save-settings-button {
            background-color: #007bff;
            color: white;
        }
        #save-settings-button:hover {
            background-color: #0056b3;
        }

        #cancel-settings-button {
            background-color: #6c757d;
            color: white;
        }
        #cancel-settings-button:hover {
            background-color: #5a6268;
        }

        /* CSS rules for the old #sidebar-toggle-button and its collapsed state are removed or commented */

        /* #sidebar.sidebar-collapsed {
            width: 0;
            padding-left: 0;
            padding-right: 0;
            overflow: visible; 
        } */
        
        /* #sidebar.sidebar-collapsed #sidebar-toggle-button {
            right: auto; 
            left: 0px; 
            border-left: 1px solid #555; 
            border-radius: 6px 0 0 6px; 
        } */

        #sidebar.sidebar-collapsed h2, /* This rule might become obsolete if sidebar uses transform */
        #sidebar.sidebar-collapsed ul,
        #sidebar.sidebar-collapsed .sidebar-actions {
            display: none; /* This is still good if we want to ensure content is hidden if transform fails or for other reasons */
        }

        .chat-item-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Ensure it takes full width of li */
        }

        .chat-item-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-item-options-button {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.1em;
            padding: 0 5px;
            cursor: pointer;
            margin-left: 5px;
            display: none; /* Hidden by default, shown on li:hover */
        }

        #sidebar li:hover .chat-item-options-button {
            display: inline-block;
        }

        .chat-options-menu {
            position: absolute;
            background-color: #343541; /* Darker than sidebar item */
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1200; /* Above sidebar items */
            min-width: 100px;
            display: none; /* Hidden by default */
        }

        .chat-options-menu button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            text-align: left;
            background: none;
            border: none;
            color: #ececec;
            cursor: pointer;
            font-size: 0.9em;
        }

        .chat-options-menu button:hover {
            background-color: #4a4a64;
        }

        /* Styles for the tool call visual representation in bot messages */
        .tool-call-visual {
            border: 1px solid #007bff; /* Blue border */
        }

    </style>
</head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <h2>Chat History</h2>
            <ul id="chat-history-list">
                <!-- Chat history items will be populated here by JavaScript -->
            </ul>
            <div class="sidebar-actions">
                <button id="settings-button">&#8942;</button> <!-- Settings Icon changed to vertical ellipsis -->
            </div>
        </div>
        <div id="chat-area">
            <div id="top-bar">
                <button id="top-bar-toggle-sidebar" title="Toggle Sidebar">☰</button> <!-- New sidebar toggle -->
                <button id="top-bar-new-chat" title="New Chat">+</button> <!-- New new chat button -->
                <div id="controls">
                    <label for="model-selector">Model:</label>
                    <select id="model-selector">
                        <option value="echo_model">Echo Model (Test)</option>
                        <optgroup label="OpenAI">
                            <option value="gpt-4o">GPT-4o</option>
                            <option value="gpt-4o-mini">GPT-4o mini</option>
                            <option value="o3">o3</option>
                            <option value="o3-mini">o3 mini</option>
                        </optgroup>
                        <optgroup label="Anthropic">
                            <option value="claude-4-sonnet">claude-4-sonnet</option>
                            <option value="claude-4-opus">claude-4-opus</option>
                            <option value="claude-3-7-sonnet">claude-3-7-sonnet</option>
                            <option value="claude-3-5-sonnet">claude-3-5-sonnet</option>
                        </optgroup>
                        <optgroup label="Google Gemini">
                            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                        </optgroup>
                    </select>
                    <!-- API Key input removed from here -->
                </div>
            </div>
            <div id="message-log">
                <!-- Messages will be appended here -->
            </div>
            <div id="input-area">
                <input type="text" id="message-input" placeholder="Type your message...">
                <button id="send-button">Send</button>
            </div>
            <div id="status">Ready</div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeSettingsModal()">&times;</span>
            <h2>Settings</h2>
            
            <label for="openai-api-key">OpenAI API Key:</label>
            <input type="password" id="openai-api-key" name="openai-api-key">

            <label for="anthropic-api-key">Anthropic API Key:</label>
            <input type="password" id="anthropic-api-key" name="anthropic-api-key">

            <label for="google-api-key">Google API Key:</label>
            <input type="password" id="google-api-key" name="google-api-key">

            <label for="preferred-model">Preferred Model:</label>
            <select id="preferred-model" name="preferred-model">
                <!-- Options will be populated by JavaScript -->
            </select>
            <button onclick="saveSettings()">Save Settings</button>
            <p id="settings-status"></p>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const messageLog = document.getElementById('message-log');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const modelSelector = document.getElementById('model-selector');
        const statusDiv = document.getElementById('status');
        const chatHistoryList = document.getElementById('chat-history-list');
        const newChatButton = document.getElementById('new-chat-button');

        // Settings Modal elements
        const settingsButton = document.getElementById('settings-button');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsModalButton = settingsModal.querySelector('.close-button');
        const openaiApiKeyInput = document.getElementById('openai-api-key');
        const anthropicApiKeyInput = document.getElementById('anthropic-api-key');
        const googleApiKeyInput = document.getElementById('google-api-key');
        const preferredModelSelect = document.getElementById('preferred-model');
        const settingsStatus = document.getElementById('settings-status');

        // New top bar buttons
        const topBarToggleSidebarButton = document.getElementById('top-bar-toggle-sidebar');
        const topBarNewChatButton = document.getElementById('top-bar-new-chat');

        let currentConversation = [];
        let allChats = {};
        let activeChatId = null;

        function addMessageToLog(sender, message, isStreaming = false) {
            // If streaming, find the last bot message with "..." and update it.
            if (isStreaming) {
                const lastBotMessage = messageLog.querySelector('.bot-message:last-child');
                if (lastBotMessage && lastBotMessage.innerHTML.endsWith('...')) {
                    lastBotMessage.innerHTML = marked.parse(message); // Use marked to parse markdown
                    messageLog.scrollTop = messageLog.scrollHeight;
                    return;
                }
            }
            
            // Otherwise, create a new message element.
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message');
            messageDiv.innerHTML = marked.parse(message); // Use marked to parse markdown
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;
        }

        // --- WebSocket Communication ---
        let socket;
        const mcp_port = 8001;
        const ws_url = `ws://localhost:${mcp_port}/mcp`;

        function connectWebSocket() {
            console.log("Attempting to connect to WebSocket at:", ws_url);
            socket = new WebSocket(ws_url);

            socket.onopen = function(event) {
                console.log("WebSocket connection established.");
                addMessageToLog('bot', 'Connected to RevitMCP. Ready for commands.');
            };

            socket.onmessage = function(event) {
                console.log("WebSocket message received:", event.data);
                const data = JSON.parse(event.data);

                let botResponseText = "Could not parse response.";
                if (data.error) {
                    botResponseText = `**Error:** ${data.error.message}`;
                } else if (data.result && data.result.content && data.result.content[0].type === 'text') {
                    const toolResult = JSON.parse(data.result.content[0].text);
                    botResponseText = `\`\`\`json\n${JSON.stringify(toolResult, null, 2)}\n\`\`\``;
                }
                
                // Update the "..." message with the final response.
                const lastBotMessage = messageLog.querySelector('.bot-message:last-child');
                if (lastBotMessage && lastBotMessage.innerHTML.includes('...')) {
                    lastBotMessage.innerHTML = marked.parse(botResponseText);
                    messageLog.scrollTop = messageLog.scrollHeight;
                } else {
                    addMessageToLog('bot', botResponseText);
                }
            };

            socket.onclose = function(event) {
                console.log("WebSocket connection closed. Attempting to reconnect...");
                addMessageToLog('bot', 'Connection lost. Trying to reconnect...');
                setTimeout(connectWebSocket, 3000);
            };

            socket.onerror = function(error) {
                console.error("WebSocket error:", error);
                addMessageToLog('bot', '**Error:** Could not connect to the WebSocket server.');
            };
        }

        function sendMessage(message) {
            addMessageToLog('user', message);
            messageInput.value = '';
            
            addMessageToLog('bot', 'Thinking...'); // Show a "thinking" message

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                console.error("WebSocket is not connected.");
                addMessageToLog('bot', 'Error: Not connected to the server. Please ensure the RevitMCP server is running and reload the page.', true);
                return;
            }

            const request = {
                jsonrpc: "2.0",
                method: "tools/call",
                params: {
                    name: message.toLowerCase().includes("list") ? "list_views" : "place_view_on_sheet",
                    arguments: message.toLowerCase().includes("list") ? {} : { view_name: message }
                },
                id: `msg_${new Date().getTime()}`
            };
            
            console.log("Sending MCP request:", request);
            socket.send(JSON.stringify(request));
        }

        // --- Event Listeners and Initialization ---
        sendButton.addEventListener('click', () => {
            const message = messageInput.value.trim();
            if (message) {
                sendMessage(message);
            }
        });

        messageInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const message = messageInput.value.trim();
                if (message) {
                    sendMessage(message);
                }
            }
        });

        connectWebSocket();

        // Wrap dependent initializations in DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initial load of chats from storage
            loadChatsFromStorage();
            loadApiKeysFromStorage(); // Load API keys on start

            // Sidebar Toggle Functionality
            const sidebar = document.getElementById('sidebar');

            // Load sidebar state from localStorage
            // Default to open (not closed), so isSidebarClosed is true if item is 'true'
            let isSidebarClosed = localStorage.getItem('revitMCP_sidebar_closed') === 'true'; 
            
            function applySidebarState() {
                if (isSidebarClosed) {
                    sidebar.classList.add('sidebar-closed');
                    topBarToggleSidebarButton.textContent = '»'; // Or your preferred "open" icon (e.g., ☰)
                } else {
                    sidebar.classList.remove('sidebar-closed');
                    topBarToggleSidebarButton.textContent = '«'; // Or your preferred "close" icon (e.g., <)
                }
            }
            // Initialize sidebar state: if nothing in localStorage, sidebar should be open (not closed).
            // So, if 'revitMCP_sidebar_closed' is null, isSidebarClosed is false.
            if (localStorage.getItem('revitMCP_sidebar_closed') === null) {
                isSidebarClosed = false; // Default to open
            }
            applySidebarState(); // Apply initial state

            topBarToggleSidebarButton.addEventListener('click', () => {
                isSidebarClosed = !isSidebarClosed; 
                applySidebarState(); 
                localStorage.setItem('revitMCP_sidebar_closed', isSidebarClosed);
            });
            
            // Connect new top-bar new chat button
            topBarNewChatButton.addEventListener('click', startNewChat);

            // Load last selected model
            const savedModel = localStorage.getItem('revitMCPselectedModel');
            if (savedModel) {
                modelSelector.value = savedModel;
            }
        });

        // --- Settings Modal Logic --- (listeners can be set up outside DOMContentLoaded)
        function openSettingsModal() {
            // Load current settings into the modal inputs
            openaiApiKeyInput.value = localStorage.getItem('revitMCP_openai_api_key') || '';
            anthropicApiKeyInput.value = localStorage.getItem('revitMCP_anthropic_api_key') || '';
            googleApiKeyInput.value = localStorage.getItem('revitMCP_google_api_key') || '';
            
            // Populate the preferred model selector by copying options from the main model selector
            preferredModelSelect.innerHTML = modelSelector.innerHTML;
            // Set the selected value for the preferred model
            const savedPreferredModel = localStorage.getItem('revitMCPselectedModel');
            if (savedPreferredModel) {
                preferredModelSelect.value = savedPreferredModel;
            } else if (modelSelector.options.length > 0) {
                preferredModelSelect.value = modelSelector.options[0].value; // Default to first option of main selector
            }

            settingsModal.style.display = 'block';
            settingsStatus.textContent = '';
        }

        function closeSettingsModal() {
            settingsModal.style.display = 'none';
        }

        function saveSettings() {
            localStorage.setItem('revitMCP_openai_api_key', openaiApiKeyInput.value.trim());
            localStorage.setItem('revitMCP_anthropic_api_key', anthropicApiKeyInput.value.trim());
            localStorage.setItem('revitMCP_google_api_key', googleApiKeyInput.value.trim());
            localStorage.setItem('revitMCPselectedModel', preferredModelSelect.value);
            
            settingsStatus.textContent = 'Settings saved!';
            // Update the main model selector as well if the preferred model changed
            // populateModelSelector(modelSelector, true); // No longer needed, main selector is static
            modelSelector.value = preferredModelSelect.value;
            
            setTimeout(() => {
                closeSettingsModal();
            }, 1000);
        }

        // Attach event listeners for settings modal
        if (settingsButton) {
            settingsButton.addEventListener('click', openSettingsModal);
        }
        if (closeSettingsModalButton) {
            closeSettingsModalButton.addEventListener('click', closeSettingsModal);
        }
        // saveSettings is called by button onclick directly in HTML

        // --- Chat History Management --- (functions defined, called by DOMContentLoaded or events)
        function generateChatId() {
            return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function saveCurrentChat() {
            if (activeChatId && currentConversation.length > 0) {
                allChats[activeChatId] = [...currentConversation];
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                renderChatHistoryList();
            }
        }
        
        function getChatTitle(conversationOrChatObject) {
            // Check if it's the full chat object which might have metadata.customTitle
            if (conversationOrChatObject && typeof conversationOrChatObject === 'object' && !Array.isArray(conversationOrChatObject)) {
                if (conversationOrChatObject.metadata && conversationOrChatObject.metadata.customTitle) {
                    return conversationOrChatObject.metadata.customTitle;
                }
                // If no customTitle, fall back to deriving from messages (assuming it has a messages array)
                // This part needs care: what if conversationOrChatObject is the array directly?
                // Let's assume the argument to getChatTitle is always the array of messages from allChats[chatId]
                // OR the chat object from allChats[chatId] which would be an array of messages (current structure)
                // OR the chat object which is an object containing messages and metadata (new structure)

                // To handle both current (array) and potential future (object with .messages):
                let messages = Array.isArray(conversationOrChatObject) ? conversationOrChatObject : conversationOrChatObject.messages;
                if (!messages) messages = []; // Fallback if structure is unexpected

                const firstUserMessage = messages.find(msg => msg.role === 'user');
                if (firstUserMessage && firstUserMessage.content) {
                    return firstUserMessage.content.substring(0, 30) + (firstUserMessage.content.length > 30 ? '...' : '');
                }
                return "New Chat"; // Default if no user message or empty
            }
            // Fallback for old calls or direct message array
            if (Array.isArray(conversationOrChatObject) && conversationOrChatObject.length === 0) return "New Chat";
            if (Array.isArray(conversationOrChatObject)) {
                const firstUserMessage = conversationOrChatObject.find(msg => msg.role === 'user');
                 if (firstUserMessage && firstUserMessage.content) {
                    return firstUserMessage.content.substring(0, 30) + (firstUserMessage.content.length > 30 ? '...' : '');
                }
            }
            
            // Fallback for empty/newly created chats before any messages if not handled above
            const chatKey = Object.keys(allChats).find(key => allChats[key] === conversationOrChatObject);
            const chatIndex = chatKey ? Object.keys(allChats).indexOf(chatKey) : -1;
            return "Chat " + (chatIndex >= 0 ? chatIndex + 1 : Object.keys(allChats).length +1) ;
        }

        function renderChatHistoryList() {
            chatHistoryList.innerHTML = '';
            const sortedChatIds = Object.keys(allChats).sort((a,b) => {
                 return parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]);
            });

            sortedChatIds.forEach(chatId => {
                const chat = allChats[chatId];
                const listItem = document.createElement('li');
                
                const container = document.createElement('div');
                container.classList.add('chat-item-container');

                const titleSpan = document.createElement('span');
                titleSpan.classList.add('chat-item-title');
                titleSpan.textContent = getChatTitle(chat); // Use existing function for now
                titleSpan.title = getChatTitle(chat); // Full title on hover

                const optionsButton = document.createElement('button');
                optionsButton.classList.add('chat-item-options-button');
                optionsButton.innerHTML = '&#8942;'; // Vertical ellipsis HTML entity
                optionsButton.title = 'More options';
                optionsButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent li click event
                    toggleChatOptionsMenu(event.currentTarget, chatId);
                });

                container.appendChild(titleSpan);
                container.appendChild(optionsButton);
                listItem.appendChild(container);

                listItem.dataset.chatId = chatId;
                if (chatId === activeChatId) {
                    listItem.classList.add('active-chat');
                }
                listItem.addEventListener('click', () => loadChat(chatId));
                chatHistoryList.appendChild(listItem);
            });
        }

        function toggleChatOptionsMenu(buttonElement, chatId) {
            closeAllOptionMenus(); // Close any other open menus
            let menu = document.getElementById('chat-options-menu-' + chatId);
            if (!menu) {
                menu = createChatOptionsMenu(chatId);
                // Position menu near the button
                const rect = buttonElement.getBoundingClientRect();
                document.body.appendChild(menu); // Append to body to avoid overflow issues
                menu.style.top = (rect.bottom + window.scrollY) + 'px';
                menu.style.left = (rect.left + window.scrollX - menu.offsetWidth + rect.width) + 'px';
            }
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        }

        function createChatOptionsMenu(chatId) {
            const menu = document.createElement('div');
            menu.id = 'chat-options-menu-' + chatId;
            menu.classList.add('chat-options-menu');

            const renameButton = document.createElement('button');
            renameButton.textContent = 'Rename';
            renameButton.addEventListener('click', () => {
                renameChat(chatId);
                menu.style.display = 'none';
            });

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
                deleteChat(chatId);
                menu.style.display = 'none';
            });

            menu.appendChild(renameButton);
            menu.appendChild(deleteButton);
            return menu;
        }

        function closeAllOptionMenus() {
            document.querySelectorAll('.chat-options-menu').forEach(menu => {
                menu.style.display = 'none';
            });
        }
        
        // Add a global click listener to close menus if clicked outside
        document.addEventListener('click', function(event) {
            const openMenus = document.querySelectorAll('.chat-options-menu');
            let clickedInsideMenu = false;
            openMenus.forEach(menu => {
                if (menu.contains(event.target)) {
                    clickedInsideMenu = true;
                }
            });
            const clickedOnOptionsButton = event.target.closest('.chat-item-options-button');

            if (!clickedInsideMenu && !clickedOnOptionsButton) {
                closeAllOptionMenus();
            }
        });

        function loadChat(chatId) {
            if (allChats[chatId]) {
                saveCurrentChat();
                activeChatId = chatId;
                currentConversation = [...allChats[chatId]];
                messageLog.innerHTML = '';
                currentConversation.forEach(msg => displayMessage(msg.role, msg.content, false));
                renderChatHistoryList();
                statusDiv.textContent = `Loaded chat: ${getChatTitle(currentConversation)}`;
            }
        }

        function startNewChat() {
            saveCurrentChat();
            activeChatId = generateChatId();
            currentConversation = [];
            messageLog.innerHTML = '';
            allChats[activeChatId] = [];
            renderChatHistoryList();
            statusDiv.textContent = 'New chat started.';
            messageInput.focus();
        }
        
        function loadChatsFromStorage() {
            const storedChats = localStorage.getItem('allRevitMCPChats');
            if (storedChats) {
                allChats = JSON.parse(storedChats);
                const chatIds = Object.keys(allChats);
                if (chatIds.length > 0) {
                    const mostRecentChatId = chatIds.sort((a,b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]))[0];
                    loadChat(mostRecentChatId || chatIds[0]);
                } else {
                    startNewChat();
                }
            } else {
                startNewChat();
            }
            renderChatHistoryList(); // This is fine here, as DOM elements exist by the time it's called
        }

        function loadApiKeysFromStorage() {
            // Implementation of loadApiKeysFromStorage function
        }

        // --- Message Display & Sending --- (functions defined, called by events)
        function displayMessage(role, message, shouldSave = true) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role === 'user' ? 'user-message' : 'bot-message');
            
            if (role === 'bot') {
                if (typeof marked !== 'undefined' && marked && typeof marked.parse === 'function') {
                    messageDiv.innerHTML = marked.parse(message || " ");
                } else {
                    console.warn("'marked' library is not available. Displaying raw message. Check CDN link or network.");
                    messageDiv.textContent = message; // Fallback to raw text
                }
            } else {
                messageDiv.textContent = message;
            }
            
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;

            if (shouldSave) {
                currentConversation.push({ role: role, content: message });
                saveCurrentChat();
            }
        }

        function renameChat(chatId) {
            const chatToRename = allChats[chatId];
            if (!chatToRename) return;

            const currentTitle = getChatTitle(chatToRename);
            const newTitle = prompt("Enter new name for chat:", currentTitle);

            if (newTitle && newTitle.trim() !== '' && newTitle !== currentTitle) {
                // If we want to store custom titles, we need to modify the chat object structure.
                // For now, let's assume getChatTitle is sufficient or we add a 'customTitle' field.
                if (!allChats[chatId].metadata) {
                    allChats[chatId].metadata = {};
                }
                allChats[chatId].metadata.customTitle = newTitle.trim();
                
                // Update localStorage immediately
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                renderChatHistoryList(); // Re-render to show new title
                if (chatId === activeChatId) {
                    statusDiv.textContent = `Chat renamed to: ${newTitle.trim()}`;
                }
            }
        }

        function deleteChat(chatId) {
            const chatToDelete = allChats[chatId];
            if (!chatToDelete) return;

            const chatTitle = getChatTitle(chatToDelete);
            if (confirm("Are you sure you want to delete chat: '" + chatTitle + "'?")) {
                delete allChats[chatId];
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                
                if (activeChatId === chatId) {
                    activeChatId = null; // Clear active chat
                    // Find the most recent remaining chat to load, or start new if none left
                    const remainingChatIds = Object.keys(allChats).sort((a,b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]));
                    if (remainingChatIds.length > 0) {
                        loadChat(remainingChatIds[0]);
                    } else {
                        startNewChat();
                    }
                } else {
                    renderChatHistoryList(); // Just re-render if a non-active chat was deleted
                }
                statusDiv.textContent = `Chat '${chatTitle}' deleted.`;
            }
        }

        function getApiKeyForModel(modelName) {
            if (!modelName) return ''; // Should not happen if a model is always selected

            if (modelName.startsWith('gpt-') || modelName.startsWith('o3-')) { // Adjusted for o3 prefix
                return localStorage.getItem('revitMCP_openai_api_key') || '';
            } else if (modelName.startsWith('claude-')) {
                return localStorage.getItem('revitMCP_anthropic_api_key') || '';
            } else if (modelName.startsWith('gemini-')) {
                return localStorage.getItem('revitMCP_google_api_key') || '';
            }
            // For 'echo_model' or any other model not matching known prefixes, no API key is needed by the backend.
            return ''; 
        }

    });
    </script>
</body>
</html> 